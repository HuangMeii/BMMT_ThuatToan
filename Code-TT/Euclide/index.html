<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thuật Toán Euclide Mở Rộng</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
  <section class="KhaiQuat">
    <h2>Định nghĩa</h2>
    <div>
      <p>
        Thuật toán Euclide mở rộng là một phiên bản mở rộng của thuật toán Euclide, được sử dụng để tìm ước số chung lớn nhất (GCD) của hai số nguyên 𝑎 và 𝑏, đồng thời tìm hai số nguyên 𝑥 và 𝑦 sao cho:
      </p>
      <p>a<i>x</i> + b<i>y</i> = gcd(a,b)</p>
      <h7>
        Đây được gọi là định lý <strong>Bézout</strong>, và các số 𝑥, 𝑦 được gọi là hệ số <strong> Bézout</strong>.
      </h7>
      <p>Thuật toán Euclide mở rộng không chỉ cho biết GCD của hai số mà còn giúp giải phương trình tuyến tính Diophantine và tìm nghịch đảo modulo, một ứng dụng quan trọng trong lý thuyết số và mật mã học.
      </p>
    </div>
    
    <div class="UngDung">

      <h2>Ứng dụng</h2>
      <div>
        <h3>Trong toán học</h3>
        <div>
          <h4>Tìm ước số chung lớn nhất (GCD):</h4>
          <p>Thuật toán Euclide mở rộng là một trong những cách hiệu quả nhất để tìm GCD của hai số nguyên, nhờ vào phương pháp chia lấy dư.</p>
        </div>
        <div>
          <h4>Chứng minh và giải các bài toán số học:</h4>
          <p>Xác định xem hai số có là nguyên tố cùng nhau hay không (gcd(a, b) = 1).</p>
          <p>Giải phương trình Diophantine tuyến tính có dạng 𝑎𝑥 + 𝑏𝑦 = 𝑐</p>
          <p>Ứng dụng trong các hệ thống số học modulo.</p>
        </div>
        <div>
          <h4>Mật mã học và lý thuyết số:</h4>
          <p>Giúp xác định số nguyên tố cùng nhau, nền tảng của các thuật toán mã hóa như RSA.</p>
          <p>Giải quyết bài toán chìa khóa công khai và chìa khóa riêng tư trong hệ thống mã hóa.</p>
        </div>
      </div>

      <div>
        <h3>Trong khoa học máy tính</h3>
        <div>
          <h4>Tính toán hiệu quả GCD trong lập trình</h4>
          <p>Thuật toán Euclide có độ phức tạp 𝑂(log⁡ max⁡(𝑎, 𝑏)) O(logmax(a,b)), giúp tính toán nhanh chóng ngay cả với các số lớn.</p>
        </div>
        <div>
      </div>
          <h4>Giải quyết các bài toán liên quan đến đồng dư</h4>
          <p>Hỗ trợ tìm nghịch đảo modulo trong hệ thống số học dư.</p>
          <p>Giúp xây dựng thuật toán mã hóa và giải mã dữ liệu.</p>
        </div>
        <div>
          <h4>Ứng dụng trong hệ điều hành và mạng máy tính</h4>
          <p>Thuật toán Euclide có thể được dùng để tối ưu hóa các thuật toán lên lịch, nén dữ liệu và xử lý đa phương tiện.</p>
          <p>Ứng dụng trong giao thức truyền dữ liệu an toàn.</p>
        </div>
      </div>
    </div>
  </section>
  <section class="TinhToan"> 
    <h1>Thuật Toán Euclide Mở Rộng</h1>
    <p>Nhập các giá trị a và b để tính toán:</p>
    <input type="number" id="inputA" placeholder="Nhập a">
    <input type="number" id="inputB" placeholder="Nhập b">
    <button onclick="calculate()">Tính Toán</button>

    <h2>Bảng Kết Quả</h2>
    <table>
        <thead>
            <tr>
                <th>q</th>
                <th>r</th>
                <th>x</th>
                <th>y</th>
                <th>a</th>
                <th>b</th>
                <th>x2</th>
                <th>x1</th>
                <th>y2</th>
                <th>y1</th>
            </tr>
        </thead>
        <tbody id="resultTableBody">
            <!-- Kết quả từng bước sẽ được thêm vào đây -->
        </tbody>
    </table>
    
    <h2>Kết Quả Cuối Cùng</h2>
    <p id="finalResult"></p>
  </section>

    <script>
        // Thuật toán Euclide Mở Rộng
        function extendedEuclid(a, b) {
            // x0, x1, y0, y1 là các biến trung gian để tính x, y
            let x0 = 1, x1 = 0, y0 = 0, y1 = 1;
            let steps = [];

            // Đẩy dòng khởi tạo (trước khi vòng lặp) vào bảng
            steps.push({
                q: '-',
                r: '-',
                x: '-',
                y: '-',
                a: a,
                b: b,
                x2: x0,
                x1: x1,
                y2: y0,
                y1: y1
            });

            // Vòng lặp chính
            while (b !== 0) {
                let q = Math.floor(a / b);
                let r = a % b;

                // Tính x, y mới
                let newX = x0 - q * x1;
                let newY = y0 - q * y1;

                // Cập nhật a, b, x0, x1, y0, y1
                a = b;
                b = r;
                x0 = x1;
                x1 = newX;
                y0 = y1;
                y1 = newY;

                // Lưu trạng thái *sau* khi cập nhật
                steps.push({
                    q: q,
                    r: r,
                    x: newX,
                    y: newY,
                    a: a,
                    b: b,
                    x2: x0,
                    x1: x1,
                    y2: y0,
                    y1: y1
                });
            }

            // a cuối cùng là gcd, x0, y0 là nghiệm
            return {
                gcd: a,
                x: x0,
                y: y0,
                steps: steps
            };
        }

        function calculate() {
            let a = parseInt(document.getElementById('inputA').value);
            let b = parseInt(document.getElementById('inputB').value);

            if (isNaN(a) || isNaN(b)) {
                alert("Vui lòng nhập số hợp lệ!");
                return;
            }

            let result = extendedEuclid(a, b);
            let steps = result.steps;
            let gcd = result.gcd;
            let resultTable = '';

            // Hiển thị từng bước trong bảng
            steps.forEach(step => {
                resultTable += `
                <tr>
                    <td>${step.q}</td>
                    <td>${step.r}</td>
                    <td>${step.x}</td>
                    <td>${step.y}</td>
                    <td>${step.a}</td>
                    <td>${step.b}</td>
                    <td>${step.x2}</td>
                    <td>${step.x1}</td>
                    <td>${step.y2}</td>
                    <td>${step.y1}</td>
                </tr>`;
            });

            document.getElementById('resultTableBody').innerHTML = resultTable;

            // Hiển thị kết quả cuối cùng
            if (gcd === 1) {
                // x0, y0 là kết quả sau vòng lặp => result.x, result.y
                // Tính nghịch đảo của a mod b (chỉ cần nếu gcd=1)
                // Lưu ý: Lúc này b có thể đã thành 0, nên cần b gốc
                // => Lưu b gốc ngay từ đầu nếu cần. Ở đây ta chỉ in gcd=1
                document.getElementById('finalResult').innerText =
                    `GCD = 1. (x, y) = (${result.x}, ${result.y}). ` +
                    `Nghịch đảo của số a mod b cũng có thể tính dựa trên x.`;
            } else {
                document.getElementById('finalResult').innerText =
                    `GCD = ${gcd}. Không có nghịch đảo vì gcd ≠ 1.`;
            }
        }
    </script>
</body>
</html>